import { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

const CosmicBackground = () => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    
    // Declare global variables
    let scene: THREE.Scene, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, composer: EffectComposer;
    let particleLayers: THREE.Points[] = [];
    let time = 0;
    const mouse = new THREE.Vector3(0, 0, 0); // Current mouse position in 3D space
    const targetMouse = new THREE.Vector3(0, 0, 0); // Target mouse position for smooth interpolation
    const mouseRadius = 20; // UPDATED: Reduced mouse interaction radius
    let ripples: any[] = []; // Array to store click ripple effects
    let animationId: number;

    // Configuration for different layers of particles
    const layersConfig = [
        {
            count: 1000,
            size: 0.3,
            colorRange: { hue: [0.75, 0.9], sat: [0.7, 1], light: [0.5, 0.7] },
            rotationSpeed: 0.001
        },
        {
            count: 25000,
            size: 0.2,
            colorRange: { hue: [0.45, 0.6], sat: [0.6, 0.8], light: [0.4, 0.6] },
            rotationSpeed: 0.0005
        }
    ];

    // Function to create a particle system based on a configuration object
    function createParticleSystem(config: any) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.count * 3);
        const colors = new Float32Array(config.count * 3);
        const basePositions = new Float32Array(config.count * 3);
        const baseColors = new Float32Array(config.count * 3);

        for (let i = 0; i < config.count; i++) {
            const i3 = i * 3;
            
            // UPDATED: Increased radius to fill the screen
            const radius = 10 + Math.random() * 100; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            // Convert spherical coordinates to Cartesian coordinates
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            positions[i3] = x;
            positions[i3 + 1] = y;
            positions[i3 + 2] = z;

            // Store the initial positions to return to
            basePositions[i3] = x;
            basePositions[i3 + 1] = y;
            basePositions[i3 + 2] = z;

            // Calculate color based on distance from the center
            const dist = Math.sqrt(x * x + y * y + z * z) / 110; // Adjusted for new radius
            const hue = THREE.MathUtils.lerp(config.colorRange.hue[0], config.colorRange.hue[1], dist);
            const sat = THREE.MathUtils.lerp(config.colorRange.sat[0], config.colorRange.sat[1], dist);
            const light = THREE.MathUtils.lerp(config.colorRange.light[0], config.colorRange.light[1], dist);

            const color = new THREE.Color().setHSL(hue, sat, light);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;

            // Store the initial colors
            baseColors[i3] = color.r;
            baseColors[i3 + 1] = color.g;
            baseColors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Use a simple texture for the particles
        const textureLoader = new THREE.TextureLoader();
        const particleTexture = textureLoader.load('https://placehold.co/32x32/ffffff/ffffff.png?text=+');

        const material = new THREE.PointsMaterial({
            size: config.size,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true,
            map: particleTexture
        });

        const points = new THREE.Points(geometry, material);
        // Store physics-related data in the userData object
        points.userData = {
            velocities: new Float32Array(config.count * 3),
            basePositions,
            baseColors,
            colorVelocities: new Float32Array(config.count * 3),
            rotationSpeed: config.rotationSpeed
        };

        return points;
    }

    // Function to create a ripple effect on click
    function createRipple(x: number, y: number) {
        ripples.push({
            x, y,
            radius: 0,
            strength: 2.5,
            maxRadius: mouseRadius * 4,
            speed: 4,
            color: new THREE.Color(0xffffff)
        });
    }

    // Initialize the scene, camera, renderer, and post-processing effects
    function init() {
        const width = container.clientWidth;
        const height = container.clientHeight;

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020108, 0.008);

        camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        // renderer.setClearColor(0x020108); // We handle background with CSS
        renderer.setClearColor(0x000000, 0); // Transparent background
        container.appendChild(renderer.domElement);

        // Setup post-processing for bloom effect
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Create and add particle layers to the scene
        layersConfig.forEach(config => {
            const particles = createParticleSystem(config);
            particleLayers.push(particles);
            scene.add(particles);
        });

        // Add event listeners
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('click', onClick);
        window.addEventListener('resize', onWindowResize);
    }

    // Update particle positions and colors based on mouse interaction and physics
    function updateParticles() {
        // Smoothly move the mouse position
        mouse.lerp(targetMouse, 0.05);

        // Update and filter active ripples
        ripples = ripples.filter(ripple => {
            ripple.radius += ripple.speed;
            ripple.strength *= 0.96; // Fade out the ripple strength
            return ripple.radius < ripple.maxRadius;
        });

        particleLayers.forEach(layer => {
            const positions = layer.geometry.attributes.position.array as Float32Array;
            const colors = layer.geometry.attributes.color.array as Float32Array;
            const { velocities, basePositions, baseColors, colorVelocities } = layer.userData;
            const totalParticles = positions.length / 3;

            for (let i = 0; i < totalParticles; i++) {
                const i3 = i * 3;
                const px = positions[i3];
                const py = positions[i3 + 1];
                const pz = positions[i3 + 2];

                let totalForce = new THREE.Vector3();
                let colorShift = new THREE.Vector3();

                // --- Mouse Interaction ---
                const mouseDist = mouse.distanceTo(new THREE.Vector3(px, py, pz));
                if (mouseDist < mouseRadius) {
                    const forceStrength = (1 - mouseDist / mouseRadius) * 0.1;
                    const forceDirection = new THREE.Vector3(px, py, pz).sub(mouse).normalize();
                    totalForce.add(forceDirection.multiplyScalar(forceStrength));
                    
                    const colorIntensity = (1 - mouseDist / mouseRadius) * 0.8;
                    colorShift.set(colorIntensity, colorIntensity, colorIntensity);
                }

                // --- Ripple Interaction ---
                ripples.forEach(ripple => {
                    const rippleDist = Math.sqrt(Math.pow(ripple.x - px, 2) + Math.pow(ripple.y - py, 2));
                    const rippleWidth = 15;
                    if (Math.abs(rippleDist - ripple.radius) < rippleWidth) {
                        const falloff = 1 - Math.abs(rippleDist - ripple.radius) / rippleWidth;
                        const rippleForce = ripple.strength * falloff * 0.1;
                        const forceDirection = new THREE.Vector3(px, py, pz).sub(new THREE.Vector3(ripple.x, ripple.y, pz)).normalize();
                        totalForce.add(forceDirection.multiplyScalar(rippleForce));
                        
                        const rippleColor = new THREE.Vector3(ripple.color.r, ripple.color.g, ripple.color.b);
                        colorShift.add(rippleColor.multiplyScalar(falloff * ripple.strength));
                    }
                });

                // Apply forces to velocities
                velocities[i3] += totalForce.x;
                velocities[i3 + 1] += totalForce.y;
                velocities[i3 + 2] += totalForce.z;

                // Force to return to base position
                const returnForce = 0.02;
                velocities[i3] += (basePositions[i3] - px) * returnForce;
                velocities[i3 + 1] += (basePositions[i3 + 1] - py) * returnForce;
                velocities[i3 + 2] += (basePositions[i3 + 2] - pz) * returnForce;

                // Damping to slow down particles
                const damping = 0.94;
                velocities[i3] *= damping;
                velocities[i3 + 1] *= damping;
                velocities[i3 + 2] *= damping;

                // Update positions
                positions[i3] += velocities[i3];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];

                // --- Color Physics ---
                colorVelocities[i3] += colorShift.x;
                colorVelocities[i3 + 1] += colorShift.y;
                colorVelocities[i3 + 2] += colorShift.z;

                const colorReturnForce = 0.05;
                colorVelocities[i3] += (baseColors[i3] - colors[i3]) * colorReturnForce;
                colorVelocities[i3 + 1] += (baseColors[i3 + 1] - colors[i3 + 1]) * colorReturnForce;
                colorVelocities[i3 + 2] += (baseColors[i3 + 2] - colors[i3 + 2]) * colorReturnForce;
                
                const colorDamping = 0.9;
                colorVelocities[i3] *= colorDamping;
                colorVelocities[i3 + 1] *= colorDamping;
                colorVelocities[i3 + 2] *= colorDamping;

                colors[i3] += colorVelocities[i3];
                colors[i3 + 1] += colorVelocities[i3 + 1];
                colors[i3 + 2] += colorVelocities[i3 + 2];
            }

            // Flag that the buffer attributes need to be updated on the GPU
            layer.geometry.attributes.position.needsUpdate = true;
            layer.geometry.attributes.color.needsUpdate = true;
        });
    }

    // The main animation loop
    function animate() {
        animationId = requestAnimationFrame(animate);
        time += 0.01;

        updateParticles();

        // Rotate the particle layers for a cosmic feel
        particleLayers.forEach(layer => {
            layer.rotation.y += layer.userData.rotationSpeed;
            layer.rotation.x = Math.sin(time * 0.1) * 0.05;
        });

        // Animate the camera position slightly
        camera.position.x = Math.sin(time * 0.2) * 2;
        camera.position.y = Math.cos(time * 0.3) * 2;
        camera.lookAt(scene.position);

        // Render the scene using the composer
        composer.render();
    }

    // Event handler for mouse movement
    function onMouseMove(event: MouseEvent) {
        const rect = container.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Convert mouse coordinates from 2D screen space to 3D world space
        targetMouse.x = (x / rect.width) * 2 - 1;
        targetMouse.y = -(y / rect.height) * 2 + 1;
        
        const vector = new THREE.Vector3(targetMouse.x, targetMouse.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = -camera.position.z / dir.z;
        const pos = camera.position.clone().add(dir.multiplyScalar(distance));
        targetMouse.copy(pos);
    }

    // Event handler for clicks
    function onClick(event: MouseEvent) {
        const rect = container.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const clickMouse = new THREE.Vector2();
        clickMouse.x = (x / rect.width) * 2 - 1;
        clickMouse.y = -(y / rect.height) * 2 + 1;
        
        const vector = new THREE.Vector3(clickMouse.x, clickMouse.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = -camera.position.z / dir.z;
        const pos = camera.position.clone().add(dir.multiplyScalar(distance));
        
        createRipple(pos.x, pos.y);
    }

    // Event handler for window resizing
    function onWindowResize() {
        const width = container.clientWidth;
        const height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);
    }

    init();
    animate();

    return () => {
        cancelAnimationFrame(animationId);
        window.removeEventListener('resize', onWindowResize);
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('click', onClick);
        
        if (container && renderer.domElement) {
            container.removeChild(renderer.domElement);
        }
        
        particleLayers.forEach(layer => {
            layer.geometry.dispose();
            (layer.material as THREE.Material).dispose();
        });
        renderer.dispose();
    };
  }, []);

  return (
    <>
        <div 
            ref={containerRef} 
            id="container" 
            style={{
                position: 'absolute',
                width: '100%',
                height: '100%',
                background: 'radial-gradient(circle at 50% 50%, #1a0632 0%, #140426 25%, #0c021a 50%, #06020e 75%, #020108 100%)',
                top: 0,
                left: 0,
                zIndex: 0
            }}
        />
        <div 
            className="glow-overlay"
            style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                background: 'radial-gradient(circle at 50% 50%, rgba(120, 50, 255, 0.05) 0%, rgba(80, 40, 200, 0.03) 40%, transparent 70%)',
                mixBlendMode: 'screen',
                zIndex: 0
            }}
        />
    </>
  );
};

export default CosmicBackground;
